% -*- coding: utf-8 -*-
% Ada 95 品质和风格
% 版权所有 (C) 2011 朱群英
% Copyright (C) 2011 Zhu Qun-Ying
%
% 本书的 TeX 代码和由之生成的 ps，pdf，html，等其他格式的文件
% 遵循 GNU通用公共授权第三版或其后的版本。
%
% 本书是基于有益的目的而加以发布，然而不负任何担保责任。
%
% 您应已收到附随于本书的GNU通用公共授权的副本；如果没有，
% 请参考 <http://www.gnu.org/licenses/gpl.html>

\section{高级结构}
\begin{blockindent}
构建良好的程序很同意被理解、提高和维护。构建糟糕的程序在维护时，
经常需要重新构建以方便工作。下面列出的许多准则，是作为通用程序设计准则
给出的。
\end{blockindent}

\subsection{分别编译能力}
\glentry{准则}
\begin{itemize}
\item 把每一个库单元的规约放在独立于实体的文件中。
\item 避免定义不是主程序的库单元子程序。如果定义了这样的子程序，
对每一个库单元子程序创建一个明确的单独的规约文件。
\item 把亚单元的使用降到最低。
\item 对于亚单元而言，用子库单元来把一个子系统构建为可管理的多个单元。
\item 每一个亚单元存放在独立的文件中。
\item 使用一致的文件命名约定。
\item 对于包主体的嵌套，用私有子包并在父包中引用。
\item 对于(其他)子单元用于扩展父单元的抽象或服务需要的数据和子程序，
 用私有子单元规约。
\end{itemize}

\glentry{范例}
\begin{blockindent}
下面的文件名说明了一种可能的文件组织以及相随的一致命名约定。
库单元的名字用后缀 adb 来表示单元主体，后缀 ads 表示单元规约，
任何其他包含亚单元的文件的名字，由体名字和亚单元名字以下划线
分隔:
\begin{lstlisting}
text_io.ads                 -- the specification
text_io.adb                 -- the body
text_io_integer_io.adb      -- a subunit
text_io_fixed_io.adb        -- a subunit
text_io_float_io.adb        -- a subunit
text_io_enumeration_io.adb  -- a subunit
\end{lstlisting}

依赖于文件系统允许文件名中可以用什么字符，你可以在文件
名字中用更清晰的方式来区分父和亚单元的名字。
如果文件系统允许使用 \texttt{"\#"} 字符，那可以用 \texttt{\#}
来分隔主体和亚单元的名字:
\begin{lstlisting}
text_io.ads                 -- the specification
text_io.adb                 -- the body
text_io#integer_io.adb      -- a subunit
text_io#fixed_io.adb        -- a subunit
text_io#float_io.adb        -- a subunit
text_io#enumeration_io.adb  -- a subunit
\end{lstlisting}

有些操作系统区分大小写，尽管 Ada 本身是不区分大小写的语言。
这时，可以选择全用小写来表示文件名。
\end{blockindent}

\glentry{原理}
\begin{blockindent}
本准则侧重在分散文件上的主要原因，是最小化每次改动后需要重新编译的
文件数。通常，在软件开发过程中，主体的改动要比规约要频繁得多。
如果规约和主体在同一个文件中，那么每次主体的编译也会编译一次规约，
虽然规约并没有改变。 因为规约定义了单元和其所有使用者之间的接口，
每次规约的重编译都会导致所有使用者必须重编译以确认符合规约。如果
使用者的规约和主体也在一个文件里，那任何使用这些单元的使用者也要
重编译，以此类推。这个涟漪效应，会强制大量本可以避免的重编译，严重
拖慢了项目的开发和测试阶段。这就是为什么你要把所有库单元 (非嵌套单元)
中的规约和其主体分别存放在不同的文件中。

库单元中子程序要尽量短小。库单元子程序的真正运用只有作为主子程序时。
几乎在其他任何情况下，把子程序嵌套在包中会更好些。这为子程序在主体中
提供了一个本地化所需数据的场所。而且，这也减低了系统中单独模块的数量。

通常，对于任何用 \texttt{with} 语句引用的库中的子程序，都应有一个单独
的规约。这让使用的单元只依赖于库子程序的规约，而不是其主体。

亚单元的使用也应该尽量的少，因为他们产生维护问题。父主体中的声明在
亚单元中是可见的，这增加了亚单元中的全局数据，因此提高了改动带来的潜在
涟漪效应。亚单元阻碍了代码的重用，因为他提供了把可能重用的代码直接放在
亚单元的便利，而不是把他们放在一个通用的例程以供其他子程序调用。

Ada 95 提供了子库单元的功能，可以避免大多数亚单元的使用。例如，
用子库单元和对应的语境语句来替代亚单元庞大而嵌套的主体。子库单元
主体的改变不会引起子系统中其他单元的重编译。

另一个使用多个独立文件的好处是，不同的程序员可以使用普通的编辑器
同时修正系统的不同部分，一般的编辑器不允许同时对一文件进行多处
修改。

最后，将规约和主体分离可以实现一个规约对应多个主体或多个规约对应一个
主体。虽然 Ada 要求在一个系统中的任何时间，一个主体只能有一个规约，
但是维护多主体或多规约对于系统的不同构建仍然有好处。例如，一个规约可以有
多个主体，每个主体都实现相同的功能，但是在时间和空间的折衷不同，
或者是依赖机器的代码，每一个目标机器都有一个对应的主体。维护多规约在开发
和调试阶段也很有用。例如，一个规约提供给客户，另一个给单元测试。前一个
只导出在正常操作下外部可以使用的子程序，后一个导出所有的子程序，
以便独立测试每一个子程序。

一致的文件命名约定是值得推荐的，这有利于管理由于遵循本准则而产生的大量文件。

在实现包规约中的抽象时，通常需要写一些支持的子程序来操纵内部数据。
不要在接口中导出这些子程序。 可以选择把他们放在父包的主体中，或者父包主体
中语境语句引用的子包中。当放在父包的主体中时，所有使用父包的客户都不能
访问他们，包括扩展父包的子包也不可以。如果实现父包抽象的扩展时，
要用到这些子程序，父包的规约和主体都将被迫修改，因为扩展必须要在父包规约
中声明。这个方法就会引起整个包 (规约和主体) 和所有客户的重编译。

也可以用私有子包来实现这些支持子程序。因为父单元的规约没有更改，他和他
的客户都不需要重编译。本来要在父单元主体中声明的数据和子程序，改在
私有子单元的规约中声明，这样他们在父单元主体和任何扩展父单元服务和抽象的子单元
中都可见。
\end{blockindent}
