% -*- coding: utf-8 -*-
% Ada 95 品质和风格
% 版权所有 (C) 2009,2010, 朱群英
% Copyright (C) 2009,2010, Zhu Qun-Ying
%
% 本书的 TeX 代码和由之生成的 ps，pdf，html，等其他格式的文件
% 遵循 GNU通用公共授权第三版或其后的版本。
%
% 本书是基于有益的目的而加以发布，然而不负任何担保责任。
%
% 您应已收到附随于本书的GNU通用公共授权的副本；如果没有，
% 请参考 <http://www.gnu.org/licenses/gpl.html>

\chapter{可读性}
\label{c:readability}

本章推荐如何使用Ada的功能，使得代码更易阅读和理解。有许多有关注释和可读性的
迷思。命名和代码结构比注释对真正的可读性承担更多的责任。拥有和代码一样多
的注释并不代表可读性；它更可能是作者不理解什么是需要沟通的重要部分。

\section{拼写}
源代码中的拼写规则包括大写、下划线的应用、数字和缩写。如果你一致遵循这些规则，
那写出来的代码就会更清晰和易读。

\subsection{下划线的应用}
\glentry{准则}
\begin{itemize}
    \item 用下划线分隔复合名字中的词。
\end{itemize}

\glentry{范例}
\begin{blockindent}
\noindent
\begin{lstlisting}
Miles_Per_Hour
Entry_Value
\end{lstlisting}
\end{blockindent}

\glentry{原理}
\begin{blockindent}
当一个标识符包括多个词，如果用下划线分隔词，那会更容易阅读。事实上，
英语中也有这样的惯例，复合词用练字符或空格分隔。另外，为了促进代码的
可读性，如果在名字中用下划线，代码格式器对于大小写有更多的控制。
参见准则\ref{s:readability:cap}。
\end{blockindent}

\subsection{数字}
\glentry{准则}
\begin{itemize}
    \item 使用一致的风格来呈现数字。
    \item 使用对问题适当的根植来呈现字面值。
    \item 使用下划线来分隔数字，就像在普通文字中用逗号或句号
(或对于非十进制用空格)。
    \item 当使用科学标示法，用一致的大写或小写的E。
    \item 在非十进制数字中，要么使用全大写或小写来标示其中的字母。
\end{itemize}

\glentry{具体事例}
\begin{blockindent}
\noindent
\begin{itemize}
    \item[-] 十进制或八进制数字，在小数点的左边，每三个数字一组，在右边，
每五个数字一组。
    \item[-] 科学标示中，总用大写字母E。
    \item[-] 用大写字母表示在十以上进制的数字。
    \item[-] 十六进制数字，小数点两边都是每四个数字一组。
\end{itemize}
\end{blockindent}

\glentry{范例}
\begin{blockindent}
\noindent
\begin{lstlisting}
type Maximum_Samples     is range          1 .. 1_000_000;
type Legal_Hex_Address   is range   16#0000# ..   16#FFFF#;
type Legal_Octal_Address is range 8#000_000# .. 8#777_777#;

Avogadro_Number : constant := 6.02216_9E+23;
\end{lstlisting}
用一下方式表示常量$1/3$:
\begin{lstlisting}
One_Third : constant := 1.0 / 3.0;
\end{lstlisting}
或
\begin{lstlisting}
One_Third_Base_3 : constant := 3#0.1#;
\end{lstlisting}
不要用:
\begin{lstlisting}
One_Third_As_Decimal_Approximation : constant := 0.33333_33333_3333;
\end{lstlisting}
\end{blockindent}

\glentry{原理}
\begin{blockindent}
大写或小写字母的一致使用，有助于搜索数字。用下划线来把数字组成熟悉的模式。
与平时使用模式的一致是可读性的一大要素。
\end{blockindent}

\glentry{注解}
\begin{blockindent}
如果一个分数用一个它可以终止的基数进制来表示，而不用一个重复的表示法，就象
上面例子中的\texttt{3\#0.1\#}，在转换到机器的基数时，有可能更精确。
\end{blockindent}

\subsection{大写}
\label{s:readability:cap}
\glentry{准则}
\begin{itemize}
    \item 让保留字和程序的其他组件从视觉上分开。
\end{itemize}
\glentry{具体事例}
\begin{blockindent}
\noindent
\begin{itemize}
    \item[-] 所有保留字用小写 (当用做保留字时)。
    \item[-] 所有其他标识符混用大小写，每个词用一个大写字母开始，
并用下划线分开。
    \item[-] 用大写字母表示缩略语或首写字母缩写 (见自动化注释)。
\end{itemize}
\end{blockindent}
\glentry{范例}
\begin{blockindent}
\noindent
\begin{lstlisting}
...

type Second_Of_Day      is range 0 .. 86_400;
type Noon_Relative_Time is (Before_Noon, After_Noon, High_Noon);

subtype Morning   is Second_Of_Day range 0 .. 86_400 / 2 - 1;
subtype Afternoon is Second_Of_Day range Morning'Last + 2 .. 86_400;

...

Current_Time := Second_Of_Day(Calendar.Seconds(Calendar.Clock));

if Current_Time in Morning then
    Time_Of_Day := Before_Noon;
elsif Current_Time in Afternoon then
    Time_Of_Day := After_Noon;
else
    Time_Of_Day := High_Noon;
end if;

case Time_Of_Day is
    when Before_Noon =>   Get_Ready_For_Lunch;
    when High_Noon   =>   Eat_Lunch;
    when After_Noon  =>   Get_To_Work;
end case;

...
\end{lstlisting}
\end{blockindent}

\glentry{原理}
\begin{blockindent}
视觉上把保留字突出来，让你集中精力在程序结构上，同时有助于扫描某个
标识符。

这里选择的具体事例对于有经验的 Ada 程序员更容易阅读，他不需要保留字
在页面上的突出。 语言的初学者常常发觉保留字的突出有助于他们更
容易的理解控制结构。 因此，学习班的教师和介绍 Ada 语言的书籍可以采用
另一种实现。 \cite{arm95} 选用粗体小写字母来书写所有的保留字。
\end{blockindent}

\glentry{自动化注解}
\begin{blockindent}
Ada 的名字是忽略大小写的。所以象 \texttt{max\_limit}、\texttt{MAX\_LIMIT}、
\texttt{Max\_Limit} 表示一样的对象或实体。只要词之间用下划线分隔，一个好的
代码格式器可以自动从一种风格转换到另一种。

正如\ref{read:abbr} 中所推荐，缩写应该是项目层的。自动化的工具应该允许一个项目
列出它的缩写并格式他们。

\end{blockindent}

\subsection{缩写}
\label{c:readability:abbr}
\glentry{准则}
\begin{itemize}
    \item 如果一个短小的同义词存在，不要使用长词语的缩写。
    \item 用一致的缩写策略。
    \item 不要用有多种解释的缩写。
    \item 缩写必须比原词节省了许多字符，以认可它的使用。
    \item 使用应用领域通用的缩写。
    \item 维护一个缩写列表，只使用列表中的缩写。
\end{itemize}

\glentry{范例}
\begin{blockindent}
用 \texttt{Time\_Of\_Recipt} 比用 \texttt{Recd\_Time} 或 \texttt{R\_Time}
要好。
但是，对于经常需要处理达到军事标准要求的信息格式， \texttt{DOD\_STD\_MSG\_FMT}
是 \texttt{Department\_Of\_Defense\_Standard\_Message\_Format}
\footnote{国防部信息格式标准} 可接受的缩写。
\end{blockindent}

\glentry{原理}
\begin{blockindent}
许多缩写需要结合上下文才不会模糊和不明确。例如，\texttt{Temp} 可以是
临时 (temporary) 或温度 (temperature)。因此，当你需要用到缩写时，要小心的
选择。准则 \ref{c:resuability:abbr} 的原理中就上下文如何影响缩写的使用有
更加彻底的讨论。

因为非常长的变量名会遮蔽程序结构，特别是在缩进的深层嵌套的控制结构中，所以
要尽量让变量名短而有意义。如果可能，尽量的使用短而不用缩写的名字。如果没有
合适的短变量名，那么众所周知的缩写是下一个最好的选择，特别是整个项目都在
使用的标准缩写列表中的名字。

使用 \texttt{rename} 语句，你可以对一个全名建立缩写。这是个很有用的功能，
当在一段本地代码中，一个出现多次的非常长的全名因而可以简化 (参见准则
\cite{c:pratice:rename})。

项目中，一个可接受的缩写列表提供了使用这些缩写的标准语境。
\end{blockindent}

\section{命名约定}
选择一个可以有助表达对象或实体运用的名字。 Ada 允许任意长度的标志符，
只要标志符所有的有效字符(含下划线)可以在一行内。 标志符就是是变量、常量、
程序单元或程序中其他实体的名字。

\subsection{名字}

\glentry{准则}
\begin{itemize}
    \item 尽量选择可以自我说明的名字。
    \item 使用短的同义词而不用缩写 (参见准则\ref{c:readability:abbr})。
    \item 使用应用的名词，但是不要用偏僻的术语。
    \item 避免使用同一个名字来声明不同类型的标识符。
\end{itemize}

\glentry{范例}
\begin{blockindent}
在一个树遍历中，用 \texttt{Left} 在这个语境中已经足够表达它的意思，不用
\texttt{Left\_Branch}。然而，要用 \texttt{Time\_Of\_Day} 而不是 \texttt{TOD}。

数学公式往往用单个字符来命名变量。在程序中，对于数学公式继续这个约定，这样
它们可以提示公式，例如：
\begin{lstlisting}
    A * (X**2) + B * X + C
\end{lstlisting}
当使用子包的时候，如果包、子单元或标志符的名字选的不好，有可能导致与子单元
的可见性冲突。\cite{rational95} (\textsection{8.1})有个因此而变得
很晦涩的代码。
\end{blockindent}

\glentry{原理}
\begin{blockindent}
遵循这些准则的程序很容易被理解。自我说明的名字需要更少的注释说明。经验表明，
如果你的变量名没有过度的长，你可以进一步增加程序的可理解性 (\cite{sch86}, 7)。
上下文和应用域可以提供很多帮助。 数字实体的测量单位是一个子类型名字的来源。

要尽量避免在不同的声明中用同一个名字作为标志符，例如一个对象和一个子包。
在表面上看起来不同的名字空间过度使用同一个标识符，如果这些程序单元要
在一些工作，实际上会导致可见性冲突。
\end{blockindent}

\glentry{注解}
\begin{blockindent}
参见准则\ref{c:resuability:abbr} 有个关于如何用应用领域作为选择缩写的指南。
\end{blockindent}

\subsection{子类型名字}
\label{c:readability:subtype}
\glentry{准则}
\begin{itemize}
    \item 使用单数、泛指的名词作为子类型标志符。
    \item 选用能说明子类型值的标志符。
    \item 对定义可见的访问类型、子界、数组，考虑在子类型标志符中用后缀。
    \item 对私有类型，不要使用针对子类型标志符的构造规则 (例如加后缀)。
    \item 不要使用预定义包中的子类型名字。
\end{itemize}

\glentry{范例}
\begin{blockindent}
\begin{lstlisting}
type Day is
   (Monday,    Tuesday,   Wednesday, Thursday, Friday,
    Saturday,  Sunday);
type Day_Of_Month    is range      0 ..    31;
type Month_Number    is range      1 ..    12;
type Historical_Year is range -6_000 .. 2_500;

type Date is
   record
      Day   : Day_Of_Month;
      Month : Month_Number;
      Year  : Historical_Year;
   end record;
\end{lstlisting}
特别指出，\texttt{Day} 应该优先于 \texttt{Days} 或 \texttt{Day\_Type} 的使用。

标志符 \texttt{Historical\_Year} 也许看起来象特指，但实际是泛指的，形容词
\texttt{historical} 说明了范围的限制。
\begin{lstlisting}
------------------------------------------------------------------------
procedure Disk_Driver is
   -- In this procedure, a number of important disk parameters are
   -- linked.
   Number_Of_Sectors  : constant :=      4;
   Number_Of_Tracks   : constant :=   200;
   Number_Of_Surfaces : constant :=    18;
   Sector_Capacity    : constant := 4_096;

   Track_Capacity   : constant := Number_Of_Sectors  * Sector_Capacity;
   Surface_Capacity : constant := Number_Of_Tracks   * Track_Capacity;
   Disk_Capacity    : constant := Number_Of_Surfaces * Surface_Capacity;

   type Sector_Range  is range 1 .. Number_Of_Sectors;
   type Track_Range   is range 1 .. Number_Of_Tracks;
   type Surface_Range is range 1 .. Number_Of_Surfaces;

   type Track_Map   is array (Sector_Range)  of ...;
   type Surface_Map is array (Track_Range)   of Track_Map;
   type Disk_Map    is array (Surface_Range) of Surface_Map;
begin -- Disk_Driver
   ...
end Disk_Driver;
------------------------------------------------------------------------
\end{lstlisting}
后缀 \texttt{\_Capacity}、\texttt{\_Range}和\texttt{\_Map} 帮助定义了上述
子类型的目的，避免了寻找抽象 sector, track 和 surface 的同义词。没有了这些
后缀，对每一个抽象你需要三个不同的名字来说明每个简洁后缀名中所描述的概念。
这个建议只对那些可见的子类型。对于私有类型，应该被赋予一个能反应抽象代表的
好名字。
\end{blockindent}

\glentry{原理}
\begin{blockindent}
当使用这个风格和建议的对象标志符风格时，程序代码更相似于英文
(参见准则\ref{c:readability:obj})。另外，这个风格和语言预定义的标志符名字
保持了一致。它们并没有被命名为 \texttt{Integers}, \texttt{Booleans},
\texttt{Interger\_Type} 或 \texttt{Boolean\_Tyoe}。

但是，如果使用预定义包中的子类型名，当子类型出现在某处而没有包限定的话，
一定会弄糊涂程序员。
\end{blockindent}

\glentry{注解}
\begin{blockindent}
这个风格准则试图和 \cite{arm95} 在对术语 ``type (类型）''
和 ``subtype (子类型) 名字'' 的使用上保持一致。通常 ``类型'' 指一个抽象的
概念，如在类型声明中，而 ``子类型'' 指在实际声明中赋予抽象概念的名字。所以
在 \cite{arm83} 中的类型现在是子类型。
\end{blockindent}

\subsection{对象名字}
\glentry{准则}
\begin{itemize}
    \item 对于逻辑对象 使用判断语或从属的名字。
    \item 使用单数、泛指的名词作为对象标志符。
    \item 选用能说明对象执行时的值的标识符。
    \item 使用单数、泛指的名词作记录的组件。
\end{itemize}

\glentry{范例}
\begin{blockindent}
\noindent
非逻辑对象:
\begin{lstlisting}
  Today           : Day;
  Yesterday       : Day;
  Retirement_Date : Date;
\end{lstlisting}
逻辑对象:
\begin{lstlisting}
  User_Is_Available : Boolean; -- predicate clause
  List_Is_Empty     : Boolean; -- predicate clause
  Empty             : Boolean; -- adjective
  Bright            : Boolean; -- adjective
\end{lstlisting}
\end{blockindent}

\glentry{原理}
\begin{blockindent}
使用针对对象的名词建立了理解对象值的语境，这正是有关子类型命名的一点
(参见准则\ref{c:readability:subtype})。这种风格下，对象的声明很像英文。
例如，上面的第一个声明可读为着者``Today is Day''。

泛指的名词用在记录的组件命名，因为一个记录的对象名会提供理解组件的语境。
因此，下面的组件可理解为``the year of retirement (退休的年份)'':
\begin{lstlisting}
    Retirement_Date.Year
\end{lstlisting}
把对象类型和语言联系起来，可以是代码看起来更像文本。例如，因为选取了恰当
的名字，下面的代码不需要注释:
\begin{lstlisting}
    if List_Is_Empty then
       Number_Of_Elements := 0;
    else
       Number_Of_Elements := Length_Of_List;
    end if;
\end{lstlisting}
\end{blockindent}

\glentry{注解}
\begin{blockindent}
如果很难找到一个合适的名词来声明一个对象在整个执行期间的值，这个对象很可能
服务于多个目的。这种情况下，应该用多个对象。
\end{blockindent}

\subsection{标签类型和相对应包的命名}
\label{c:readability:tag}
\glentry{准则}
\begin{itemize}
    \item 使用一致的命名约定来对标签类型和相对应包命名。
\end{itemize}

\glentry{具体事例}
\begin{blockindent}
命名约定点燃了``信仰战争''; 因此，这里展现展了两种具体实例。第一种实例集成了
面向对象的使用特性。除了两种特殊情况，它在声明种使用同一命名约定，不管是否
用到了面向对象的特性:
\begin{itemize}
    \item[-] 对标签类型和子类型的命名一致
(参见准则\ref{c:readability:subtype})。
    \item[-] 对于导出会有多个实现的抽象 (参见准则\ref{c:oof:abstract}) 的包，
使用前缀 \texttt{Abstract\_}。
    \item[-] 对于提供可以和主要抽象``mixed in (混合)''的功能单元的包，
用后缀 \texttt{\_Mixin}。
\end{itemize}
第二种实现用特殊的名字和后缀来突出面向对象的特性的使用:
\begin{itemize}
    \item[-] 用代表的对象来命名类包，不用后缀 (\cite{rosen95})。
    \item[-] 用混合包所代表的一面类命名，用后缀 \texttt{\_Facet}
	     (\cite{rosen95})。
    \item[-] 用 \texttt{Instance} 命名主标签类型。
    \item[-] 沿用某个类型的声明，对应的类程子类型用 \texttt{Class}。
\end{itemize}
\end{blockindent}

\glentry{范例}
\begin{blockindent}
下面的两组从\cite{rational95} (\textsection{4.4.4}, \textsection{4.6.2})
中选出的例子，使用了第一种命名约定。

在第一组的例子种，假设 \texttt{Set\_Element} 已经在别的地方声明过了:
\begin{lstlisting}
  package Abstract_Sets is
     type Set is abstract tagged private;
     -- empty set
     function Empty return Set is abstract;
     -- build set with 1 element
     function Unit (Element: Set_Element) return Set is abstract;
     -- union of two sets
     function Union (Left, Right: Set) return Set is abstract;
     -- intersection of two sets
     function Intersection (Left, Right: Set) return Set is abstract;
     -- remove an element from a set
     procedure Take (From      : in out Set;
                      Element :     out set_Element) is abstract;
     Element_Too_Large : exception;
  private
     type Set is abstract tagged null record;
  end Abstract_Sets;
  with Abstract_Sets;
  package Bit_Vector_Sets is     -- one implementation of set abstraction
     type Bit_Set is new Abstract_Sets.Set with private;
     ...
  private
     Bit_Set_Size : constant := 64;
     type Bit_Vector is ...
     type Bit_Set is new Abstract_Sets.Set with
         record
            Data : Bit_Vector;
         end record;
  end Bit_Vector_Sets;
  with Abstract_Sets;
  package Sparse_Sets   -- alternate implementation of set abstraction
     type Sparse_Set is new Abstract_Sets.Set with private;
     ...
  private
     ...
  end Bit_Vector_Sets;
\end{lstlisting}

第二组例子是个支持视窗系统的混合包，应用了混合包的命名约定:
\begin{lstlisting}
  -- assume you have type Basic_Window is tagged limited private;
  generic
     type Some_Window is abstract new Basic_Window with private;
  package Label_Mixin is
     type Window_With_Label is abstract new Some_Window with private;
     ...
  private
     ...
  end Label_Mixin;
  generic
     type Some_Window is abstract new Basic_Window with private;
  package Border_Mixin is
     type Window_With_Label is abstract new Some_Window with private;
     ...
  private
     ...
  end Border_Mixin;
\end{lstlisting}

下面的例子应用了第二种命名约定，是\cite{rosen95}中讨论的:
\begin{lstlisting}
  package Shape is
     subtype Side_Count is range 0 .. 100;
     type Instance (Sides: Side_Count) is tagged private;
     subtype Class is Instance'Class;
     . . .
     -- operations on Shape.Instance
  private
     . . .
  end Shape;

  with Shape; use Shape;
  package Line is
     type Instance is new Shape.Instance with private;
     subtype Class is Instance'Class;
     . . .
     -- Overridden or new operations
  private
     . . .
  end Line;
  with Shape; use Shape;
  generic
     type Origin is new Shape.Instance;
  package With_Color_Facet is
     type Instance is new Origin with private;
     subtype Class is Instance'Class;
     -- operations for colored shapes
  private
     . . .
  end With_Color_Facet;
  with Line; use Line;
  with With_Color_Facet;
  package Colored_Line is new With_Color_Facet (Line.Instance);
\end{lstlisting}
声明看起来会是这样:
\begin{lstlisting}
  Red_Line : Colored_Line.Instance;
  procedure Draw (What : Shape.Instance);
\end{lstlisting}
上述方案在用全名或用 \texttt{use} 语句都工作。只要你用同样的名字来
表示所有的类型和类程类型，没有确认的名字总是相互隐藏。因此，编译器会
要求你使用全名称来解决用\texttt{use} 语句所带来的多义性 \cite{rosen95}。
\end{blockindent}

\glentry{原理}
\begin{blockindent}
你应采用一个一致、可读、传达抽象意图的命名方案。理想状况下，命名方案应统一
处理从不同方法用标签类型生成类别。如果命名约定太死板，从可读性的角度看，
那你写的代码片段会不自然。对于推导或通用混合的(\ref{c:oof:mul-inh}
类型夸展使用相近的命名约定，对象和过程的声明变得可读。
\end{blockindent}

\glentry{注解}
\begin{blockindent}
类的命名约定在面向对象的抽象和其他抽象间画了一条分界线。工程师们已经用 Ada 83
(\cite{arm83}) 定义抽象数据类型有十多年了，你并不想只是为了使用某个类型的
类型扩展而改变命名约定。你必须考虑所有在程序里使用的抽象中，继承有多重要。
一般情况下，如果你喜欢突出抽象，而不是实现抽象的机制 (例如：继承、类型夸展
以及多态), 也许你并不想强加这么一个苛刻的命名约定。一个平滑的从开发没有继承的
抽象过渡到开发有继承的抽象的命名约定，不会影响质量。

如果你选用了突出使用面向对象特性的命名约定，而之后有想改变声明到不用
面向对象特性，这个改变也许会代价高昂。你必须更换所有出现的名字，并且不引入
别的错误。如果你选用了一个命名约定，禁止使用前、后缀来描述声明的特性，你
失去了一个传递声明使用意图的机会。
\end{blockindent}

\subsection{程序单元的名字}
\glentry{准则}
\begin{itemize}
    \item 用行动的动词来命名过程和入口。
    \item 用判断式的子句命名逻辑函数。
    \item 用名词命名非逻辑函数。
    \item 给包的名字要暗含比子程序高级的组构。通常来说，这都是描述供应的抽象的
名词。
    \item 给任务命名隐含活动的实体。
    \item 用描述被保护数据的名词来命名保护单元。
    \item 把通用子程序当做非通用子程序来命名。
    \item 把通用包当做非通用包来命名。
    \item 通用名字应给比例示的名字更广泛。
\end{itemize}

\glentry{范例}
\begin{blockindent}
\noindent
下面是些一个Ada程序的构成元素的名字样本：

过程名字样本:
\begin{lstlisting}
    procedure Get_Next_Token -- get is a transitive verb
    procedure Create         -- create is a transitive verb
\end{lstlisting}

逻辑函数名字样本:
\begin{lstlisting}
    function Is_Last_Item -- predicate clause
    function Is_Empty     -- predicate clause
\end{lstlisting}

非逻辑函数名字样本:
\begin{lstlisting}
    function Successor -- common noun
    function Length    -- attribute
    function Top       -- component
\end{lstlisting}

包名字样本:
\begin{lstlisting}
    package Terminals is     -- common noun
    package Text_Routines is -- common noun
\end{lstlisting}

被保护对象样本:
\begin{lstlisting}
    protected Current_Location is -- data being protected
    protected type Guardian is    -- noun implying protection
\end{lstlisting}

任务名字样本:
\begin{lstlisting}
    task Terminal_Resource_Manager is -- common noun that shows action
\end{lstlisting}

下面这段代码样本，因为使用语言部分命名约定而呈现的清晰结果:
\begin{lstlisting}
    Get_Next_Token(Current_Token);
    case Current_Token is
       when Identifier =>          Process_Identifier;
       when Numeric    =>          Process_Numeric;
    end case; -- Current_Token
    if Is_Empty(Current_List) then
       Number_Of_Elements := 0;
    else
       Number_Of_Elements := Length(Current_List);
    end if;
\end{lstlisting}

当包和她的子程序一起被指定，能得到非常有描述性的代码:
\begin{lstlisting}
    if Stack.Is_Empty(Current_List) then
       Current_Token := Stack.Top(Current_List);
    end if;
\end{lstlisting}
\end{blockindent}

\glentry{原理}
\begin{blockindent}
当使用这些命名约定，代码会易于理解，读起来也象自然语言。当动词
用于行动，如子程序，名词用于对象，例如子程序处理的数据，写出的
代码更容易阅读和理解。这里模仿了读者熟悉的交流媒体。一段程序模拟
了现实中的情况，使用这样的约定，减少了阅读和理解程序种的翻译次数。
某种意义上，你选择的名字反应了从电脑硬件到应用要求的抽象级别。

有关标签类型相关的包中，特殊意义的后缀使用，
参见准则\ref{c:readability:tag} 。
\end{blockindent}

\glentry{注解}
\begin{blockindent}
当前，对于任务的进入的命名，有些相互矛盾的命名约定。有些程序员和
设计员提倡任务的进入使用和子程序一样的命名约定，模糊了程序中包含了
任务的事实。他们的理由是如果任务用包重新实现或反之，名字不需要被
替换。其他人则喜欢尽可能的突出任务存在的事实，以保证能分辨出任务的
存在和它所带来的假设额外开销。
\end{blockindent}

\subsection{常量和命名的数字}
\glentry{准则}
\begin{itemize}
    \item 尽量用符号的名字而不是文字。
    \item 对于数学常量 \texttt{Pi} 和 \texttt{e},
用预定义的常量 \texttt{Ada.Numerics.Pi} 和 \texttt{Ada.Numerics.e}。
    \item 用常量而不是变量来表示常数。
    \item 当一个值是某个类型所特有的或这个值必须静止，用常量。
    \item 尽量用命名的数字，而不是常量。
    \item 用命名的数字来代替文字的数字，它的类型或属性是真正的通用的。
    \item 对于对象的值在确立之后不能改变的，用常量(\cite{united87})。
    \item 用静止表达式来表示符号间的关系。
    \item 用线性的独立的文字组。
    \item 尽量用属性 \texttt{'First} 或者 \texttt{'Last} 而不是文字。
\end{itemize}
\section{注释}
\glentry{准则}

\section{使用类型}

\section{总结}
\glentry{拼写}
\noindent
\begin{itemize}
    \item 用下划线分隔复合名字中的词。
    \item 使用一致的风格来呈现数字。
    \item 使用对问题适当的根植来呈现字面值。
    \item 使用下划线来分隔数字，就像在普通文字中用逗号或句号
(或对于非十进制用空格)。
    \item 当使用科学标示法，用一致的大写或小写的E。
    \item 在非十进制数字中，要么使用全大写或小写来标示其中的字母。
    \item 让保留字和程序的其他组件从视觉上分开。
    \item 如果一个短小的同义词存在，不要使用长词语的缩写。
    \item 用一致的缩写策略。
    \item 不要用有多种解释的缩写。
    \item 缩写必须比原词节省了许多字符，以认可它的使用。
    \item 使用应用领域通用的缩写。
    \item 维护一个缩写列表，只使用列表中的缩写。
\end{itemize}

\glentry{命名约定}
\noindent
\begin{itemize}
    \item 尽量选择可以自我说明的名字。
    \item 使用短的同义词而不用缩写。
    \item 使用应用的名词，但是不要用偏僻的术语。
    \item 避免使用同一个名字来声明不同类型的标识符。
    \item 使用单数、泛指的名词作为子类型标志符。
    \item 选用能说明子类型值的标志符。
    \item 对定义可见的访问类型、子界、数组，考虑在子类型标志符中用后缀。
    \item 对私有类型，不要使用针对子类型标志符的构造规则 (例如加后缀)。
    \item 不要使用预定义包中的子类型名字。
    \item 对于逻辑对象 使用判断语或从属的名字。
    \item 使用单数、泛指的名词作为对象标志符。
    \item 选用能说明对象执行时的值的标识符。
    \item 使用单数、泛指的名词作记录的组件。
    \item 使用一致的命名规则来对标签类型和相对应包命名。

    \item 用行动的动词来命名过程和入口。
    \item 用判断式的子句命名逻辑函数。
    \item 用名词命名非逻辑函数。
    \item 给包的名字要暗含比子程序高级的组构。通常来说，这都是描述供应的抽象的
名词。
    \item 给任务命名隐含活动的实体。
    \item 用描述被保护数据的名词来命名保护单元。
    \item 把通用子程序当做非通用子程序来命名。
    \item 把通用包当做非通用包来命名。
    \item 通用名字应给比例示的名字更广泛。

    \item 尽量用符号的名字而不是文字。
    \item 对于数学常量 \texttt{Pi} 和 \texttt{e},
用预定义的常量 \texttt{Ada.Numerics.Pi} 和 \texttt{Ada.Numerics.e}。
    \item 用常量而不是变量来表示常数。
    \item 当一个值是某个类型所特有的或这个值必须静止，用常量。
    \item 尽量用命名的数字，而不是常量。
    \item 用命名的数字来代替文字的数字，它的类型或属性是真正的通用的。
    \item 对于对象的值在确立之后不能改变的，用常量(\cite{united87})。
    \item 用静止表达式来表示符号间的关系。
    \item 用线性的独立的文字组。
    \item 尽量用属性 \texttt{'First} 或者 \texttt{'Last} 而不是文字。

\end{itemize}

