% -*- coding: utf-8 -*-
% Ada 95 品质和风格
% 版权所有 (C) 2011 朱群英
% Copyright (C) 2011 Zhu Qun-Ying
%
% 本书的 TeX 代码和由之生成的 ps，pdf，html，等其他格式的文件
% 遵循 GNU通用公共授权第三版或其后的版本。
%
% 本书是基于有益的目的而加以发布，然而不负任何担保责任。
%
% 您应已收到附随于本书的GNU通用公共授权的副本；如果没有，
% 请参考 <http://www.gnu.org/licenses/gpl.html>

\section{总结}
\glentry{高级结构}
\begin{itemize}
\item 把每一个库单元的规约放在独立于实体的文件中。
\item 避免定义不是主程序的库单元子程序。如果定义了这样的子程序，
对每一个库单元子程序创建一个明确的单独的规约文件。
\item 把亚单元的使用降到最低。
\item 对于亚单元而言，用子库单元来把一个子系统构建为可管理的多个单元。
\item 每一个亚单元存放在独立的文件中。
\item 使用一致的文件命名约定。
\item 对于包主体的嵌套，用私有子包并在父包中引用。
\item 对于(其他)子单元用于扩展父单元的抽象或服务需要的数据和子程序，
 用私有子单元规约。

\item 尽可能通过编译器参数或其他不需要修改代码的形式来配置编译指示。
\item 当配置编译指示必须放在代码中时，考虑在每一个分区中把他们隔离
在一个编译单元里。如果要指定，推荐用分区的主子程序。

\item 用子程序来增加抽象度。
\item 限制每个子程序只执行单一动作。

\item 当子程序的主要目的是提供单一值时，用函数。
\item 最小化函数的副作用。
\item 当值不需要是静态时，考虑用无参数函数。
\item 当导出类型需要继承基类型的值时，用无参数函数 (不要用常数)。
\item 如果值本身有可能被改变，用无参数函数。

\item 用包来实现信息隐藏。
\item 用含有标签类型和私有类型的包来实现抽象数据类型。
\item 用包把相关的类型和对象定义组在一起
      (例如，两个或更多库单元的相同声明部分)。
\item 将机器依赖封装在包中。将某个设备的软件接口放在一个包中，以便更换
到另一种设备。
\item 将底层实现的决策或接口放在包中的子程序。
\item 用包和子程序来封装和隐藏可能改变的的程序细节 (\cite{nissen84})。

\item 让每个包只用于一个目的。
\item 用包把相关的数据、类型和子程序组在一起。
\item 避免收集没有关系的对象和子程序 (\cite{nasa87}, \cite{nissen84})。
\item 考虑系统的重构, 把两个紧密相关的单元合并到一个包或包的分层结构中，
又或者把相对独立的单元分到不同的包里。

\item 避免在包规范中定义变量。

\item 在问题域中用任务来对抽象、异步的实体建模。
\item 用任务定义多处理器架构中的并行算法。
\item 用任务执行并行、循环或排序的事件 (\cite{nasa87})。

\item 用保护类型来控制或同步对数据或设备的访问。
\item 用保护类型来实现任务间的同步，如被动的资源监视。
\end{itemize}

\glentry{可见度}
\begin{itemize}
\item 只把使用包需要的信息放在规范中。
\item 最小化包规范中的声明数量。
\item 不要因为容易建立而包含额外的操作。
\item 在包规范中，最小化语境语句 (\texttt{with})。
\item 重新考虑有大量参数的子程序。
\item 不要为了限制参数的数量而在子程序或包中操纵全局数据。
\item 避免不必要的可见度，对用户隐藏程序的具体实现。
\item 用子库单元来控制子系统接口的可见度。
\item 用私有子库单元来声明外部用不到的信息。
\item 用子库单元来对不同客户呈现某一实体的不同视点。
\item 在找出各样预期客户的接口逻辑后，设计(及重设计) 接口。

\end{itemize}
